
<!DOCTYPE html>
<html lang=cn>
<head>
    
        
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <link rel=stylesheet type="text/css" href=https:&#x2F;&#x2F;www.linyinfeng.com&#x2F;normalize.css>
        <link rel=stylesheet type="text/css" href=https:&#x2F;&#x2F;www.linyinfeng.com&#x2F;style.css>
        <title>
    Lin Yinfeng
    - Rust 闭包笔记
</title>
    
</head>
<body>
    
        <header id="header">
            
            
    <div class="header-container container">
        <h1 id="blog-title" class="title"><a href=https:&#x2F;&#x2F;www.linyinfeng.com>Lin Yinfeng</a></h1>
        <nav id="global-nav"><span class="global-nav-item-container"><a class="global-nav-item"
                    href=https:&#x2F;&#x2F;www.linyinfeng.com
                >Home</a></span><span class="global-nav-item-container"><a class="global-nav-item"
                    href=&#x2F;archive
                >Archive</a></span><span class="global-nav-item-container"><a class="global-nav-item"
                    href=https:&#x2F;&#x2F;github.com&#x2F;linyinfeng
                >GitHub</a></span><span class="global-nav-item-container"><a class="global-nav-item"
                    href=https:&#x2F;&#x2F;github.com&#x2F;linyinfeng&#x2F;blog
                >Source</a></span></nav>
    </div>

            
        </header>
        <div id="main-aside-container">
            
    
        
                <aside id="aside">
                    <div id="aside-container">
                        
    
    <div class="toc-container container">
        <h1 class="title toc-title">Table of Contents</h1>
        
    
        <ul class="toc-parent">
                
                <li class="toc-entry">
                    <a href=https:&#x2F;&#x2F;www.linyinfeng.com&#x2F;posts&#x2F;how-do-rust-closures-work&#x2F;#bi-bao-de-gai-nian>闭包的概念</a>
                    
    
        <ul class="toc-parent">
                
                <li class="toc-entry">
                    <a href=https:&#x2F;&#x2F;www.linyinfeng.com&#x2F;posts&#x2F;how-do-rust-closures-work&#x2F;#bi-bao-shi-ni-ming-han-shu-ma>闭包是匿名函数吗？</a>
                    
    

                </li>
                
                <li class="toc-entry">
                    <a href=https:&#x2F;&#x2F;www.linyinfeng.com&#x2F;posts&#x2F;how-do-rust-closures-work&#x2F;#bi-bao-tong-chang-bei-shi-xian-wei-ci-fa-huan-jing-he-yi-ge-han-shu-de-zu-he>闭包通常被实现为词法环境和一个函数的组合</a>
                    
    

                </li>
                
        </ul>
    

                </li>
                
                <li class="toc-entry">
                    <a href=https:&#x2F;&#x2F;www.linyinfeng.com&#x2F;posts&#x2F;how-do-rust-closures-work&#x2F;#yi-ge-po-su-rust-bi-bao-de-she-ji-yu-shi-xian>一个朴素 Rust 闭包的设计与实现</a>
                    
    

                </li>
                
                <li class="toc-entry">
                    <a href=https:&#x2F;&#x2F;www.linyinfeng.com&#x2F;posts&#x2F;how-do-rust-closures-work&#x2F;#nei-zhi-bi-bao>内置闭包</a>
                    
    
        <ul class="toc-parent">
                
                <li class="toc-entry">
                    <a href=https:&#x2F;&#x2F;www.linyinfeng.com&#x2F;posts&#x2F;how-do-rust-closures-work&#x2F;#move-guan-jian-zi>move 关键字</a>
                    
    

                </li>
                
                <li class="toc-entry">
                    <a href=https:&#x2F;&#x2F;www.linyinfeng.com&#x2F;posts&#x2F;how-do-rust-closures-work&#x2F;#mut-bi-bao>mut 闭包</a>
                    
    

                </li>
                
                <li class="toc-entry">
                    <a href=https:&#x2F;&#x2F;www.linyinfeng.com&#x2F;posts&#x2F;how-do-rust-closures-work&#x2F;#zhu-dong-zhi-ding-bi-bao-lei-xing>主动指定闭包类型</a>
                    
    

                </li>
                
                <li class="toc-entry">
                    <a href=https:&#x2F;&#x2F;www.linyinfeng.com&#x2F;posts&#x2F;how-do-rust-closures-work&#x2F;#nei-zhi-bi-bao-yu-shi-xian-de-bi-bao-de-qu-bie-yu-lian-xi>内置闭包与实现的闭包的区别与联系</a>
                    
    

                </li>
                
        </ul>
    

                </li>
                
        </ul>
    

    </div>


                    </div>
                </aside>
            
    

            <main id="main">
                <div id="main-container">
                    
    
                    
    
    <article class="article-container container">
        
    <h1 class="title article-title">
        <a class="article-title-link" href="https:&#x2F;&#x2F;www.linyinfeng.com&#x2F;posts&#x2F;how-do-rust-closures-work&#x2F;">
            
    
        [Draft]
    
    Rust 闭包笔记

        </a>
    </h1>

        
    <time datetime=2018-08-02T11:55:02+08:00>2018-08-02 11:55</time>

        
    <div class="article-taxonomies"><span class="article-taxonomy"><a class="article-taxonomy-name" href="https:&#x2F;&#x2F;www.linyinfeng.com&#x2F;tags">
                Tags</a><span class="article-terms"><span class="article-term-name">rust</span><span class="article-term-name">闭包</span><span class="article-term-name">函数式编程</span></span></span><span class="article-taxonomy"><a class="article-taxonomy-name" href="https:&#x2F;&#x2F;www.linyinfeng.com&#x2F;categories">
                Categories</a><span class="article-terms"><span class="article-term-name">笔记</span></span></span></div>

        
    
        <section class="article-license">
            
                <div class="license-image">
                    <img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="Creative Commons License" />
                </div>
            
            <small class="license">This work is licensed under a <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a></small>
        </section>
    

        <section class="article-content"><p>近日在学习 Rust 语言。Rust 语言的闭包设计非常有趣，一方面，它看起来非常复杂，为了支持闭包设计了三种不同的 trait，Fn、FnMut 和 FnOnce；一方面其设计又透露出了语言设计中闭包的本质。通过考察 Rust 闭包的设计，我们能更好的理解闭包到底是什么，在拥有生存期和借用检查的语言 Rust 中，闭包如何工作。</p>
<p>本文将在 Rust 下实现一个能够阐述闭包工作原理的朴素版闭包（也是一个 Boxed Closure）。并在实现的基础上对 Rust 闭包作进一步探究。</p>
<p><a name="continue-reading"></a></p>
<h1 id="bi-bao-de-gai-nian"><a class="zola-anchor" href="#bi-bao-de-gai-nian" aria-label="Anchor link for: bi-bao-de-gai-nian">🔗</a>
闭包的概念</h1>
<p>闭包（Closure）是一个在计算机科学中广泛使用的概念，又叫词法闭包（Lexical Closure）。即闭包能够“捕获”词法作用域中的变量，这是与编译时代码的结构直接相关的。也就是说，在<strong>声明闭包而不是闭包被调用的时候</strong>，其函数体可以捕获外围词法作用域中的变量。</p>
<h2 id="bi-bao-shi-ni-ming-han-shu-ma"><a class="zola-anchor" href="#bi-bao-shi-ni-ming-han-shu-ma" aria-label="Anchor link for: bi-bao-shi-ni-ming-han-shu-ma">🔗</a>
闭包是匿名函数吗？</h2>
<p>这两个概念之间没有什么关系，就以<a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">维基百科 Closure 词条</a>上举的一个常见的 adder 例子来说：</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;"> </span><span style="color:#c0c5ce;">Python
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">f</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">x</span><span style="color:#c0c5ce;">):
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">g</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">y</span><span style="color:#c0c5ce;">):
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">x + y
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return </span><span style="color:#c0c5ce;">g
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">h</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">x</span><span style="color:#c0c5ce;">):
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">return lambda </span><span style="color:#bf616a;">y</span><span style="color:#c0c5ce;">: x + y
</span><span style="color:#c0c5ce;">a = </span><span style="color:#bf616a;">f</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;">b = </span><span style="color:#bf616a;">h</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">)
</span><span style="color:#c0c5ce;"> </span><span style="color:#d08770;">...
</span></pre>
<p>在这两个例子中，a 和 b 均为闭包，JavaScript 中的 function 也是一样，是不是闭包当然和没有名字并没有理论和实践上的联系。当然，可以说对于将函数设计为一等对象（First class object）的语言，函数是否匿名一般不产生任何实际区别。</p>
<h2 id="bi-bao-tong-chang-bei-shi-xian-wei-ci-fa-huan-jing-he-yi-ge-han-shu-de-zu-he"><a class="zola-anchor" href="#bi-bao-tong-chang-bei-shi-xian-wei-ci-fa-huan-jing-he-yi-ge-han-shu-de-zu-he" aria-label="Anchor link for: bi-bao-tong-chang-bei-shi-xian-wei-ci-fa-huan-jing-he-yi-ge-han-shu-de-zu-he">🔗</a>
闭包通常被实现为词法环境和一个函数的组合</h2>
<p>对于函数基于栈的且没有垃圾回收（Garbage Collection）的语言，往往无法实现完全的闭包。这是因为，闭包从语义上应当能够**延长其捕获的变量的生存期（lifetime）**到长于或等于闭包的生存期。对于广泛利用栈进行函数局部变量分配和流程控制的语言，函数的局部变量的生存期严格与函数调用栈绑定，即从函数调用到函数返回（严格来说是局部变量内存的生存期，显然局部变量的生存期必然小于等于其内存的生存期）。</p>
<p>举例来说，有上述特征的 C++ 的闭包就易于引发为定义行为（Undefined Behavior）。因为其引用捕获的局部变量的生存期无法自动延长。而例如 Java，JavaScript 和 Go 的闭包就不会，因为其编译器（对于 JavaScript 来说往往是 JIT 编译器）将对局部变量做逃逸分析（Escape Analysis）。将可能“逃逸”的变量生存期延长，由垃圾回收器而不是函数调用栈维护其生存期。又或者将所有局部变量分配在堆上由垃圾回收器维护也是一样（效率比较低下）。</p>
<p>即使如此，各个语言下闭包的基本表现是不变的。因此，闭包通常被实现为其捕获的词法环境和一个函数的组合。</p>
<p>考虑一个名为 closure，调用方式为 closure(arg1, arg2, ..., argN)，其捕获了变量 env_arg1, env_arg2, ..., env_argM。可以将其实现为一个函数和其词法环境的组合：</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">env: (env_arg1, ..., env_argM),
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">f: fn(env_arg1, ..., env_argM, arg1, ..., argN),
</span><span style="color:#c0c5ce;">}
</span></pre><h1 id="yi-ge-po-su-rust-bi-bao-de-she-ji-yu-shi-xian"><a class="zola-anchor" href="#yi-ge-po-su-rust-bi-bao-de-she-ji-yu-shi-xian" aria-label="Anchor link for: yi-ge-po-su-rust-bi-bao-de-she-ji-yu-shi-xian">🔗</a>
一个朴素 Rust 闭包的设计与实现</h1>
<p>理解了闭包是什么，我们就可以写出一个朴素的闭包。最终我们实现的闭包<strong>用起来</strong>将会有点繁琐（无自动类型推导），但行为几乎与内置闭包一致。最终实现将会看起来像一个类似于 C++ 14 Generalized Lambda Capture 特性的闭包宏。</p>
<p>另外，虽然这个闭包看起来将与内置闭包差不多，实际上的区别是有的，不只是无类型推导这一点，这些内容将在实现后一一阐述。</p>
<p>因为提到了 C++ 14 Generalized Lambda Capture, 所以先解释一下这是什么特性，以下是一个例子：</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">auto</span><span style="color:#c0c5ce;"> c = [ v = </span><span style="color:#bf616a;">std::move</span><span style="color:#c0c5ce;">(v) ] { </span><span style="color:#65737e;">// A generalized capture list
</span><span style="color:#c0c5ce;">    </span><span style="color:#bf616a;">do_something_with</span><span style="color:#c0c5ce;">( v )
</span><span style="color:#c0c5ce;">};
</span></pre>
<p>在 C++ 14 之前，捕获列表中只能按值或者按引用捕获变量，通过 Generalized Lambda Capture，C++ 实现了捕获任意表达式，同时也顺便实现了移动捕获。</p>
<p>其实，Rust 的闭包与 C++ <strong>语义和使用上的设计</strong>几乎可以说是非常相似，但是由于 Rust 做出的内存安全（Memory Safe）承诺，引入了三个不同的 trait。将这个放在一边，我们按朴素思想实现一个闭包的结构，或者说数据。</p>
<pre style="background-color:#2b303b;">
<span style="color:#65737e;">/// Wrong implementation
</span><span style="color:#b48ead;">pub struct </span><span style="color:#c0c5ce;">Closure&lt;Env, Args, Out&gt; {
</span><span style="color:#c0c5ce;">    </span><span style="color:#bf616a;">env</span><span style="color:#c0c5ce;">: Env,
</span><span style="color:#c0c5ce;">    </span><span style="color:#bf616a;">f</span><span style="color:#c0c5ce;">: </span><span style="color:#b48ead;">fn</span><span style="color:#c0c5ce;">(Env, Args) -&gt; Out,
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>由于 Rust 中有元组的存在，我们可以简单地把所有捕获变量的类型用一个类型变量（Type Parameter）Env 表示，所有调用参数的类型用 Args 表示，最后单独用 Out 表示调用结果类型。</p>
<p>考量这个设计，闭包含有一个环境和指针合理吗？从<strong>实现功能的角度</strong>是合理的（后面我们将看到这个设计的问题所在）。</p>
<p>继续考量这个设计。将环境实现为 Env 类型是否合理？合理，闭包应该拥有（Own）其捕获的内容（即使拥有的是引用（Reference）也是拥有）。这些内容的生存期应与闭包是相同的。将函数设计为 fn(Env, Args) -&gt; Out 是否合理？对于返回值来说肯定是合理的，对于 Args 来说也是，因为函数调用的时候将拥有其参数（即使拥有的是引用）。对于拥有引用的概念，可以举一个例子：</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> v1 = String::new();
</span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> v2 = String::new();
</span><span style="color:#b48ead;">let mut</span><span style="color:#c0c5ce;"> v3 = String::new();
</span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> t = (v1, &amp;v2, &amp;</span><span style="color:#b48ead;">mut</span><span style="color:#c0c5ce;"> v3); </span><span style="color:#65737e;">// Type: (String, &amp;String, &amp;mut String)
</span></pre>
<p>构造的 tuple 字面量按语义来说移动给了变量 t，其包含两个 String 引用并拥有一个 String。</p>
<p>但是 Env 的设计是不合理的，这样设计意味着函数将获得闭包中 Closure 的所有权并不归还，这样此闭包将只能调用一次。归根结底，函数有 move, &amp;mut 和 &amp; 三种不同的对变量的使用方式。这三种方式在 Rust 现行类型系统中是无法统一的。因为 Move 闭包将只能调用一次，&amp;mut 闭包将造成对其环境的可变借用（Mutable borrowing），&amp; 闭包将造成对其环境的不可变借用（Immutable borrowing）。Rust 的生存期机制和借用检查必须对这三种闭包作出区别，或者说，这三种闭包必然在调用时携带不同的类型信息以用来检查。对比之下，C++ 的闭包则并不区别，operator() 的 this 类型始终为一个指向闭包对象的指针，虽然能够实现所有功能但是无法携带不同类型信息。</p>
<p>区分三种不同的 Env 后:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">pub struct </span><span style="color:#c0c5ce;">MoveClosure&lt;Env, Args, Out&gt; {
</span><span style="color:#c0c5ce;">    </span><span style="color:#bf616a;">env</span><span style="color:#c0c5ce;">: Env,
</span><span style="color:#c0c5ce;">    </span><span style="color:#bf616a;">f</span><span style="color:#c0c5ce;">: </span><span style="color:#b48ead;">fn</span><span style="color:#c0c5ce;">(Env, Args) -&gt; Out,
</span><span style="color:#c0c5ce;">}
</span><span style="color:#b48ead;">pub struct </span><span style="color:#c0c5ce;">RefMutClosure&lt;Env, Args, Out&gt; {
</span><span style="color:#c0c5ce;">    </span><span style="color:#bf616a;">env</span><span style="color:#c0c5ce;">: Env,
</span><span style="color:#c0c5ce;">    </span><span style="color:#bf616a;">f</span><span style="color:#c0c5ce;">: </span><span style="color:#b48ead;">fn</span><span style="color:#c0c5ce;">(&amp;</span><span style="color:#b48ead;">mut</span><span style="color:#c0c5ce;"> Env, Args) -&gt; Out,
</span><span style="color:#c0c5ce;">}
</span><span style="color:#b48ead;">pub struct </span><span style="color:#c0c5ce;">RefClosure&lt;Env, Args, Out&gt; {
</span><span style="color:#c0c5ce;">    </span><span style="color:#bf616a;">env</span><span style="color:#c0c5ce;">: Env,
</span><span style="color:#c0c5ce;">    </span><span style="color:#bf616a;">f</span><span style="color:#c0c5ce;">: </span><span style="color:#b48ead;">fn</span><span style="color:#c0c5ce;">(&amp;Env, Args) -&gt; Out,
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>当我们写出一个闭包，即往往是写出一个函数体时，其携带的函数应该是由编译器自动推导得出的。得益于 Rust 的类型推导机制，Rust 的闭包做到了，而 C++ 的闭包并没有做到，这也是为什么 C++ 需要手动写出捕获列表而 Rust 不用。归根结底，Rust 闭包的这三种类型是由函数体对闭包环境的使用方式决定的。不要误将 Rust 带有 move 关键字的闭包和 FnOnce 对应，他们实际上没有什么关系。后面我们可以看到，闭包在捕获时和调用时的行为应该分开分析。</p>
<p>为了使我们的闭包可以被调用，应该实现对应的 trait。由于上述区别，Rust 对可调用对象也无法有类似 C++ operator() 的统一的 trait。对三种不同的 self 参数必须有三种不同的函数类型。因此，Rust 在 std::ops 中定义了 FnOnce, FnMut 和 Fn 三个不同的 trait：</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">pub trait </span><span style="color:#c0c5ce;">FnOnce&lt;Args&gt; {
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">type </span><span style="color:#c0c5ce;">Output;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">extern </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">rust-call</span><span style="color:#c0c5ce;">&quot; </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">call_once</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">args</span><span style="color:#c0c5ce;">: Args) -&gt; </span><span style="color:#b48ead;">Self::</span><span style="color:#c0c5ce;">Output;
</span><span style="color:#c0c5ce;">}
</span><span style="color:#b48ead;">pub trait </span><span style="color:#c0c5ce;">FnMut&lt;Args&gt;: FnOnce&lt;Args&gt; {
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">extern </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">rust-call</span><span style="color:#c0c5ce;">&quot; </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">call_mut</span><span style="color:#c0c5ce;">(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">args</span><span style="color:#c0c5ce;">: Args) -&gt; </span><span style="color:#b48ead;">Self::</span><span style="color:#c0c5ce;">Output;
</span><span style="color:#c0c5ce;">}
</span><span style="color:#b48ead;">pub trait </span><span style="color:#c0c5ce;">Fn&lt;Args&gt;: FnMut&lt;Args&gt; {
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">extern </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">rust-call</span><span style="color:#c0c5ce;">&quot; </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">call</span><span style="color:#c0c5ce;">(&amp;</span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">args</span><span style="color:#c0c5ce;">: Args) -&gt; </span><span style="color:#b48ead;">Self::</span><span style="color:#c0c5ce;">Output;
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>其中 extern &quot;rust-call&quot; 是专用于这几个 trait 的调用约定（Calling Convention，一种 ABI），区别于 Rust 本身的调用约定 extern &quot;Rust&quot;。</p>
<p>为了手动为我们的对象实现这三种 trait，我们需要开启两个不稳定的 Rust 特性（Feature）：</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">![</span><span style="color:#96b5b4;">feature</span><span style="color:#c0c5ce;">(fn_traits, unboxed_closures)]
</span></pre>
<p>为三种闭包实现所有可以实现的 trait：</p>
<p>MoveClosure:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">impl</span><span style="color:#c0c5ce;">&lt;Env, Args, Out&gt; FnOnce&lt;Args&gt; </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">MoveClosure&lt;Env, Args, Out&gt; {
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">type </span><span style="color:#c0c5ce;">Output = Out;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">extern </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">rust-call</span><span style="color:#c0c5ce;">&quot; </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">call_once</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">args</span><span style="color:#c0c5ce;">: Args) -&gt; </span><span style="color:#b48ead;">Self::</span><span style="color:#c0c5ce;">Output {
</span><span style="color:#c0c5ce;">        </span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.f)(</span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.env, args)
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>RefMutClosure:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">impl</span><span style="color:#c0c5ce;">&lt;Env, Args, Out&gt; FnOnce&lt;Args&gt; </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">RefMutClosure&lt;Env, Args, Out&gt; {
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">type </span><span style="color:#c0c5ce;">Output = Out;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">extern </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">rust-call</span><span style="color:#c0c5ce;">&quot; </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">call_once</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">args</span><span style="color:#c0c5ce;">: Args) -&gt; </span><span style="color:#b48ead;">Self::</span><span style="color:#c0c5ce;">Output {
</span><span style="color:#c0c5ce;">        </span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.f)(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.env, args)
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">}
</span><span style="color:#b48ead;">impl</span><span style="color:#c0c5ce;">&lt;Env, Args, Out&gt; FnMut&lt;Args&gt; </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">RefMutClosure&lt;Env, Args, Out&gt; {
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">extern </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">rust-call</span><span style="color:#c0c5ce;">&quot; </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">call_mut</span><span style="color:#c0c5ce;">(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">args</span><span style="color:#c0c5ce;">: Args) -&gt; </span><span style="color:#b48ead;">Self::</span><span style="color:#c0c5ce;">Output {
</span><span style="color:#c0c5ce;">        </span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.f)(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.env, args)
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>RefClosure:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">impl</span><span style="color:#c0c5ce;">&lt;Env, Args, Out&gt; FnOnce&lt;Args&gt; </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">RefClosure&lt;Env, Args, Out&gt; {
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">type </span><span style="color:#c0c5ce;">Output = Out;
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">extern </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">rust-call</span><span style="color:#c0c5ce;">&quot; </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">call_once</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">args</span><span style="color:#c0c5ce;">: Args) -&gt; </span><span style="color:#b48ead;">Self::</span><span style="color:#c0c5ce;">Output {
</span><span style="color:#c0c5ce;">        </span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.f)(&amp;</span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.env, args)
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">}
</span><span style="color:#b48ead;">impl</span><span style="color:#c0c5ce;">&lt;Env, Args, Out&gt; FnMut&lt;Args&gt; </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">RefClosure&lt;Env, Args, Out&gt; {
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">extern </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">rust-call</span><span style="color:#c0c5ce;">&quot; </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">call_mut</span><span style="color:#c0c5ce;">(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">args</span><span style="color:#c0c5ce;">: Args) -&gt; </span><span style="color:#b48ead;">Self::</span><span style="color:#c0c5ce;">Output {
</span><span style="color:#c0c5ce;">        </span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.f)(&amp;</span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.env, args)
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">}
</span><span style="color:#b48ead;">impl</span><span style="color:#c0c5ce;">&lt;Env, Args, Out&gt; Fn&lt;Args&gt; </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">RefClosure&lt;Env, Args, Out&gt; {
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">extern </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">rust-call</span><span style="color:#c0c5ce;">&quot; </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">call</span><span style="color:#c0c5ce;">(&amp;</span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">args</span><span style="color:#c0c5ce;">: Args) -&gt; </span><span style="color:#b48ead;">Self::</span><span style="color:#c0c5ce;">Output {
</span><span style="color:#c0c5ce;">        </span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.f)(&amp;</span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.env, args)
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>编写过程中不难发现，所有的 Fn 一定能被实现为 FnMut 和 FnOnce，所有的 FnMut 一定能够被实现为 FnOnce，反之则不行。对于确定的类型，Rust 将选择最宽松的一个调用，即按照 Fn &gt; FnMut &gt; FnOnce 的优先级。</p>
<p>最后再给三个结构实现创建闭包的 new 函数，作用是隐藏内部环境和函数。</p>
<p>现在我们可以通过翻译一些程序，实际使用上面编写的闭包：</p>
<pre style="background-color:#2b303b;">
<span style="color:#65737e;">// 内置闭包
</span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> x = </span><span style="color:#d08770;">1</span><span style="color:#b48ead;">i32</span><span style="color:#c0c5ce;">;
</span><span style="color:#b48ead;">let </span><span style="color:#8fa1b3;">c </span><span style="color:#c0c5ce;">= |</span><span style="color:#bf616a;">y</span><span style="color:#c0c5ce;">| x + y;
</span><span style="color:#c0c5ce;">assert_eq!(</span><span style="color:#96b5b4;">c</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#b48ead;">i32</span><span style="color:#c0c5ce;">), </span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">);
</span><span style="color:#c0c5ce;">
</span><span style="color:#65737e;">// 手动实现的闭包
</span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> x = </span><span style="color:#d08770;">1</span><span style="color:#b48ead;">i32</span><span style="color:#c0c5ce;">;
</span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> c = {
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> env = (x,);
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">f</span><span style="color:#c0c5ce;">((</span><span style="color:#bf616a;">x</span><span style="color:#c0c5ce;">,): &amp;(</span><span style="color:#bf616a;">i32</span><span style="color:#c0c5ce;">,), (</span><span style="color:#bf616a;">y</span><span style="color:#c0c5ce;">,): (</span><span style="color:#b48ead;">i32</span><span style="color:#c0c5ce;">,)) -&gt; </span><span style="color:#b48ead;">i32 </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">        </span><span style="color:#c0c5ce;">x + y
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">RefClosure::new(env, f)
</span><span style="color:#c0c5ce;">};
</span><span style="color:#c0c5ce;">assert_eq!(</span><span style="color:#96b5b4;">c</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">), </span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">);
</span></pre>
<p>注意上例中 i32 实现了 Copy。</p>
<p>其中 let c 后创建闭包的内容其实是模式化的，编写一个简单的 macro_rules 宏将其简化：</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">[macro_export] </span><span style="color:#96b5b4;">macro_rules! </span><span style="color:#c0c5ce;">boxed_closure {
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">(move [$(</span><span style="color:#bf616a;">$env_name</span><span style="color:#c0c5ce;">:ident: </span><span style="color:#bf616a;">$env_type</span><span style="color:#c0c5ce;">:ty = </span><span style="color:#bf616a;">$env_exp</span><span style="color:#c0c5ce;">:expr,)*]
</span><span style="color:#c0c5ce;">        </span><span style="color:#c0c5ce;">($(</span><span style="color:#bf616a;">$arg_name</span><span style="color:#c0c5ce;">:ident: </span><span style="color:#bf616a;">$arg_type</span><span style="color:#c0c5ce;">:ty,)*) -&gt; </span><span style="color:#bf616a;">$out</span><span style="color:#c0c5ce;">:ty </span><span style="color:#bf616a;">$body</span><span style="color:#c0c5ce;">:block) =&gt; ({
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">f</span><span style="color:#c0c5ce;">(($(</span><span style="color:#bf616a;">$env_name</span><span style="color:#c0c5ce;">,)*): ($(</span><span style="color:#bf616a;">$env_type</span><span style="color:#c0c5ce;">,)*), ($(</span><span style="color:#bf616a;">$arg_name</span><span style="color:#c0c5ce;">,)*): ($(</span><span style="color:#bf616a;">$arg_type</span><span style="color:#c0c5ce;">,)*)) -&gt; </span><span style="color:#bf616a;">$out $body
</span><span style="color:#c0c5ce;">        </span><span style="color:#bf616a;">$crate</span><span style="color:#c0c5ce;">::</span><span style="color:#b48ead;">MoveClosure::</span><span style="color:#c0c5ce;">new(($(</span><span style="color:#bf616a;">$env_exp</span><span style="color:#c0c5ce;">,)*), f)
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">});
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">(move [$(</span><span style="color:#bf616a;">$env_name</span><span style="color:#c0c5ce;">:ident: </span><span style="color:#bf616a;">$env_type</span><span style="color:#c0c5ce;">:ty = </span><span style="color:#bf616a;">$env_exp</span><span style="color:#c0c5ce;">:expr,)*]
</span><span style="color:#c0c5ce;">        </span><span style="color:#c0c5ce;">($(</span><span style="color:#bf616a;">$arg_name</span><span style="color:#c0c5ce;">:ident: </span><span style="color:#bf616a;">$arg_type</span><span style="color:#c0c5ce;">:ty,)*) </span><span style="color:#bf616a;">$body</span><span style="color:#c0c5ce;">:block) =&gt; ({
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">f</span><span style="color:#c0c5ce;">(($(</span><span style="color:#bf616a;">$env_name</span><span style="color:#c0c5ce;">,)*): ($(</span><span style="color:#bf616a;">$env_type</span><span style="color:#c0c5ce;">,)*), ($(</span><span style="color:#bf616a;">$arg_name</span><span style="color:#c0c5ce;">,)*): ($(</span><span style="color:#bf616a;">$arg_type</span><span style="color:#c0c5ce;">,)*)) </span><span style="color:#bf616a;">$body
</span><span style="color:#c0c5ce;">        </span><span style="color:#bf616a;">$crate</span><span style="color:#c0c5ce;">::MoveClosure::new(($(</span><span style="color:#bf616a;">$env_exp</span><span style="color:#c0c5ce;">,)*), f)
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">});
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">(ref mut [$(</span><span style="color:#bf616a;">$env_name</span><span style="color:#c0c5ce;">:ident: </span><span style="color:#bf616a;">$env_type</span><span style="color:#c0c5ce;">:ty = </span><span style="color:#bf616a;">$env_exp</span><span style="color:#c0c5ce;">:expr),*,]
</span><span style="color:#c0c5ce;">        </span><span style="color:#c0c5ce;">($(</span><span style="color:#bf616a;">$arg_name</span><span style="color:#c0c5ce;">:ident: </span><span style="color:#bf616a;">$arg_type</span><span style="color:#c0c5ce;">:ty),*,) -&gt; </span><span style="color:#bf616a;">$out</span><span style="color:#c0c5ce;">:ty </span><span style="color:#bf616a;">$body</span><span style="color:#c0c5ce;">:block) =&gt; ({
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">f</span><span style="color:#c0c5ce;">(($(</span><span style="color:#bf616a;">$env_name</span><span style="color:#c0c5ce;">,)*): &amp;</span><span style="color:#b48ead;">mut </span><span style="color:#c0c5ce;">($(</span><span style="color:#bf616a;">$env_type</span><span style="color:#c0c5ce;">,)*), ($(</span><span style="color:#bf616a;">$arg_name</span><span style="color:#c0c5ce;">,)*): ($(</span><span style="color:#bf616a;">$arg_type</span><span style="color:#c0c5ce;">,)*)) -&gt; </span><span style="color:#bf616a;">$out $body
</span><span style="color:#c0c5ce;">        </span><span style="color:#bf616a;">$crate</span><span style="color:#c0c5ce;">::</span><span style="color:#b48ead;">RefMutClosure::</span><span style="color:#c0c5ce;">new(($(</span><span style="color:#bf616a;">$env_exp</span><span style="color:#c0c5ce;">,)*), f)
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">});
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">(ref mut [$(</span><span style="color:#bf616a;">$env_name</span><span style="color:#c0c5ce;">:ident: </span><span style="color:#bf616a;">$env_type</span><span style="color:#c0c5ce;">:ty = </span><span style="color:#bf616a;">$env_exp</span><span style="color:#c0c5ce;">:expr),*,]
</span><span style="color:#c0c5ce;">        </span><span style="color:#c0c5ce;">($(</span><span style="color:#bf616a;">$arg_name</span><span style="color:#c0c5ce;">:ident: </span><span style="color:#bf616a;">$arg_type</span><span style="color:#c0c5ce;">:ty),*,) </span><span style="color:#bf616a;">$body</span><span style="color:#c0c5ce;">:block) =&gt; ({
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">f</span><span style="color:#c0c5ce;">(($(</span><span style="color:#bf616a;">$env_name</span><span style="color:#c0c5ce;">,)*): &amp;</span><span style="color:#b48ead;">mut </span><span style="color:#c0c5ce;">($(</span><span style="color:#bf616a;">$env_type</span><span style="color:#c0c5ce;">,)*), ($(</span><span style="color:#bf616a;">$arg_name</span><span style="color:#c0c5ce;">,)*): ($(</span><span style="color:#bf616a;">$arg_type</span><span style="color:#c0c5ce;">,)*)) </span><span style="color:#bf616a;">$body
</span><span style="color:#c0c5ce;">        </span><span style="color:#bf616a;">$crate</span><span style="color:#c0c5ce;">::RefMutClosure::new(($(</span><span style="color:#bf616a;">$env_exp</span><span style="color:#c0c5ce;">,)*), f)
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">});
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">(ref [$(</span><span style="color:#bf616a;">$env_name</span><span style="color:#c0c5ce;">:ident: </span><span style="color:#bf616a;">$env_type</span><span style="color:#c0c5ce;">:ty = </span><span style="color:#bf616a;">$env_exp</span><span style="color:#c0c5ce;">:expr),*,]
</span><span style="color:#c0c5ce;">        </span><span style="color:#c0c5ce;">($(</span><span style="color:#bf616a;">$arg_name</span><span style="color:#c0c5ce;">:ident: </span><span style="color:#bf616a;">$arg_type</span><span style="color:#c0c5ce;">:ty),*,) -&gt; </span><span style="color:#bf616a;">$out</span><span style="color:#c0c5ce;">:ty </span><span style="color:#bf616a;">$body</span><span style="color:#c0c5ce;">:block) =&gt; ({
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">f</span><span style="color:#c0c5ce;">(($(</span><span style="color:#bf616a;">$env_name</span><span style="color:#c0c5ce;">,)*): &amp;($(</span><span style="color:#bf616a;">$env_type</span><span style="color:#c0c5ce;">,)*), ($(</span><span style="color:#bf616a;">$arg_name</span><span style="color:#c0c5ce;">,)*): ($(</span><span style="color:#bf616a;">$arg_type</span><span style="color:#c0c5ce;">,)*)) -&gt; </span><span style="color:#bf616a;">$out $body
</span><span style="color:#c0c5ce;">        </span><span style="color:#bf616a;">$crate</span><span style="color:#c0c5ce;">::</span><span style="color:#b48ead;">RefClosure::</span><span style="color:#c0c5ce;">new(($(</span><span style="color:#bf616a;">$env_exp</span><span style="color:#c0c5ce;">,)*), f)
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">});
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">(ref [$(</span><span style="color:#bf616a;">$env_name</span><span style="color:#c0c5ce;">:ident: </span><span style="color:#bf616a;">$env_type</span><span style="color:#c0c5ce;">:ty = </span><span style="color:#bf616a;">$env_exp</span><span style="color:#c0c5ce;">:expr),*,]
</span><span style="color:#c0c5ce;">        </span><span style="color:#c0c5ce;">($(</span><span style="color:#bf616a;">$arg_name</span><span style="color:#c0c5ce;">:ident: </span><span style="color:#bf616a;">$arg_type</span><span style="color:#c0c5ce;">:ty),*,) </span><span style="color:#bf616a;">$body</span><span style="color:#c0c5ce;">:block) =&gt; ({
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">f</span><span style="color:#c0c5ce;">(($(</span><span style="color:#bf616a;">$env_name</span><span style="color:#c0c5ce;">,)*): &amp;($(</span><span style="color:#bf616a;">$env_type</span><span style="color:#c0c5ce;">,)*), ($(</span><span style="color:#bf616a;">$arg_name</span><span style="color:#c0c5ce;">,)*): ($(</span><span style="color:#bf616a;">$arg_type</span><span style="color:#c0c5ce;">,)*)) </span><span style="color:#bf616a;">$body
</span><span style="color:#c0c5ce;">        </span><span style="color:#bf616a;">$crate</span><span style="color:#c0c5ce;">::RefClosure::new(($(</span><span style="color:#bf616a;">$env_exp</span><span style="color:#c0c5ce;">,)*), f)
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">});
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>上述闭包可被翻译为：</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> x = </span><span style="color:#d08770;">1</span><span style="color:#b48ead;">i32</span><span style="color:#c0c5ce;">;
</span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> c = boxed_closure! {
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">ref </span><span style="color:#c0c5ce;">[x: </span><span style="color:#b48ead;">i32 </span><span style="color:#c0c5ce;">= x,] (y: </span><span style="color:#b48ead;">i32</span><span style="color:#c0c5ce;">,) -&gt; </span><span style="color:#b48ead;">i32 </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">        </span><span style="color:#c0c5ce;">x + y
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">};
</span><span style="color:#c0c5ce;">assert_eq!(</span><span style="color:#96b5b4;">c</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">), </span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">);
</span></pre>
<p>完整 crate 已经上传到 GitHub 仓库 <a href="https://github.com/linyinfeng/closure">linyinfeng/closure</a>。注意，这是一个非常简陋的闭包设计，仅仅用于阐述一个典型闭包的工作原理。相比于 Rust 内置闭包来说，它的设计是简洁的，使用是繁琐的，性能是低下的。下面将对 Rust 内置闭包的工作进行分析和探讨，同时也与实现的朴素闭包作比较。</p>
<h1 id="nei-zhi-bi-bao"><a class="zola-anchor" href="#nei-zhi-bi-bao" aria-label="Anchor link for: nei-zhi-bi-bao">🔗</a>
内置闭包</h1>
<h2 id="move-guan-jian-zi"><a class="zola-anchor" href="#move-guan-jian-zi" aria-label="Anchor link for: move-guan-jian-zi">🔗</a>
move 关键字</h2>
<p>move 关键字的意义有时令人感到困惑。在远古 Rust 中，move 关键字是另作他用的，后来被删除了。应该是在现在版本的闭包出现以后才重新作为一个有用的关键字出现。在内置闭包捕获变量的时候，Rust 一般情况下总是尽可能以 &amp; &gt; &amp;mut &gt; move 的顺序进行捕获，这将对捕获的变量产生最少的影响。但是，某些情况下，我们需要闭包的生存期长于某个变量，但是闭包函数并不需要获得变量的所有权。这时候我们使用 move 关键字强制 Rust 将所有捕获的变量移动入闭包的环境中，以延长被移动的对象的生存期。</p>
<p>可以考虑一下为什么有 move 闭包却没有 mut 闭包呢？因为强制 mut 捕获并不会造成任何的好处却会对被捕获的变量产生一个可变借用，这没有任何意义，就与写了 let r = &amp;mut x; 却不修改 r 一样，编译器将提示去除 mut。</p>
<h2 id="mut-bi-bao"><a class="zola-anchor" href="#mut-bi-bao" aria-label="Anchor link for: mut-bi-bao">🔗</a>
mut 闭包</h2>
<p>下面示例代码中的 c 变量有时候也令人感到困惑。</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">let mut</span><span style="color:#c0c5ce;"> s = String::from(&quot;</span><span style="color:#a3be8c;">Hello</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">let mut </span><span style="color:#8fa1b3;">c </span><span style="color:#c0c5ce;">= || s.</span><span style="color:#96b5b4;">push</span><span style="color:#c0c5ce;">(&#39;</span><span style="color:#a3be8c;">!</span><span style="color:#c0c5ce;">&#39;); </span><span style="color:#65737e;">// !
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">c</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">c</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">assert_eq!(s, &quot;</span><span style="color:#a3be8c;">Hello!!</span><span style="color:#c0c5ce;">&quot;);
</span></pre>
<p>为什么编译器要求 c 必须是可变的才能执行 c() 呢？这是因为不能通过不可变引用闭包修改其内容，包括其中的可变引用。另一方面，也可以从类型上看，无法将不可变的内置闭包传递给要求可变 self 引用的 call_mut。</p>
<h2 id="zhu-dong-zhi-ding-bi-bao-lei-xing"><a class="zola-anchor" href="#zhu-dong-zhi-ding-bi-bao-lei-xing" aria-label="Anchor link for: zhu-dong-zhi-ding-bi-bao-lei-xing">🔗</a>
主动指定闭包类型</h2>
<p>Rust 曾经有过不止一两版的闭包设计，但是少有提及。以下语法是刚开始的 Unboxed Closure 提供的（参见 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0114-closures.md">rfc#114</a>）：</p>
<pre style="background-color:#2b303b;">
<span style="color:#65737e;">// Deprecated
</span><span style="color:#b48ead;">let </span><span style="color:#8fa1b3;">_move_closure </span><span style="color:#c0c5ce;">= |:| {};
</span><span style="color:#b48ead;">let </span><span style="color:#8fa1b3;">_ref_mut_closure </span><span style="color:#c0c5ce;">= |&amp;</span><span style="color:#bf616a;">mut</span><span style="color:#c0c5ce;">:| {};
</span><span style="color:#b48ead;">let </span><span style="color:#8fa1b3;">_ref_closure </span><span style="color:#c0c5ce;">= |&amp;:| {};
</span></pre>
<p>实际上便与上文实现三种闭包类型对应，如今的闭包移除了这个语法。依靠自动推导显然是更好的办法。编译器将尽可能实现调用起来更宽松的闭包。（当然我们实现的朴素闭包并没有这个功能）</p>
<h2 id="nei-zhi-bi-bao-yu-shi-xian-de-bi-bao-de-qu-bie-yu-lian-xi"><a class="zola-anchor" href="#nei-zhi-bi-bao-yu-shi-xian-de-bi-bao-de-qu-bie-yu-lian-xi" aria-label="Anchor link for: nei-zhi-bi-bao-yu-shi-xian-de-bi-bao-de-qu-bie-yu-lian-xi">🔗</a>
内置闭包与实现的闭包的区别与联系</h2>
<p>上文实现的闭包实际上与内置闭包非常相似，翻译后使用起来基本没有区别。</p>
<p>但是区别还是有的，首先是先前提到过的没有类型推导，所有捕获和类型都必须显示写出。</p>
<p>而最重要的一点是上文偶尔提到的 boxed 和 unboxed，这是什么意思呢。可以试验取上文实现的闭包的一个结构的大小和内置闭包的大小作比较：</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">![</span><span style="color:#96b5b4;">feature</span><span style="color:#c0c5ce;">(core_intrinsics)]
</span><span style="color:#c0c5ce;">[macro_use] </span><span style="color:#b48ead;">extern crate</span><span style="color:#c0c5ce;"> boxed_closure;
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">type_of</span><span style="color:#c0c5ce;">&lt;T&gt;(_: &amp;T) -&gt; &amp;</span><span style="color:#b48ead;">&#39;static str </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">unsafe </span><span style="color:#c0c5ce;">{ std::intrinsics::type_name::&lt;T&gt;() }
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">size_of</span><span style="color:#c0c5ce;">&lt;T&gt;(_: &amp;T) -&gt; </span><span style="color:#b48ead;">usize </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">std::mem::size_of::&lt;T&gt;()
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">() {
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">let mut</span><span style="color:#c0c5ce;"> s = String::from(&quot;</span><span style="color:#a3be8c;">Hello</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">let mut </span><span style="color:#8fa1b3;">c </span><span style="color:#c0c5ce;">= || s.</span><span style="color:#96b5b4;">push</span><span style="color:#c0c5ce;">(&#39;</span><span style="color:#a3be8c;">!</span><span style="color:#c0c5ce;">&#39;);
</span><span style="color:#c0c5ce;">        </span><span style="color:#c0c5ce;">println!(&quot;</span><span style="color:#a3be8c;">Type of a closure c: </span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;, </span><span style="color:#96b5b4;">type_of</span><span style="color:#c0c5ce;">(&amp;c));
</span><span style="color:#c0c5ce;">        </span><span style="color:#c0c5ce;">println!(&quot;</span><span style="color:#a3be8c;">Size of a closure c: </span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;, </span><span style="color:#96b5b4;">size_of</span><span style="color:#c0c5ce;">(&amp;c));
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">c</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">c</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">assert_eq!(s, &quot;</span><span style="color:#a3be8c;">Hello!!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">let mut</span><span style="color:#c0c5ce;"> s = String::from(&quot;</span><span style="color:#a3be8c;">Hello</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">        </span><span style="color:#b48ead;">let mut</span><span style="color:#c0c5ce;"> c = boxed_closure! {
</span><span style="color:#c0c5ce;">            </span><span style="color:#b48ead;">ref mut </span><span style="color:#c0c5ce;">[s: &amp;</span><span style="color:#b48ead;">mut </span><span style="color:#c0c5ce;">String = &amp;</span><span style="color:#b48ead;">mut</span><span style="color:#c0c5ce;"> s,] () {
</span><span style="color:#c0c5ce;">                </span><span style="color:#c0c5ce;">s.</span><span style="color:#96b5b4;">push</span><span style="color:#c0c5ce;">(&#39;</span><span style="color:#a3be8c;">!</span><span style="color:#c0c5ce;">&#39;);
</span><span style="color:#c0c5ce;">            </span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">        </span><span style="color:#c0c5ce;">};
</span><span style="color:#c0c5ce;">        </span><span style="color:#c0c5ce;">println!(&quot;</span><span style="color:#a3be8c;">Type of a closure c: </span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;, </span><span style="color:#96b5b4;">type_of</span><span style="color:#c0c5ce;">(&amp;c));
</span><span style="color:#c0c5ce;">        </span><span style="color:#c0c5ce;">println!(&quot;</span><span style="color:#a3be8c;">Size of a closure c: </span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;, </span><span style="color:#96b5b4;">size_of</span><span style="color:#c0c5ce;">(&amp;c));
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">c</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">        </span><span style="color:#96b5b4;">c</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">assert_eq!(s, &quot;</span><span style="color:#a3be8c;">Hello!!</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>输出</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">Type of a closure c: [closure@src/main.rs:15:21: 15:35 s:&amp;mut std::string::String]
</span><span style="color:#c0c5ce;">Size of a closure c: 8
</span><span style="color:#c0c5ce;">Type of a closure c: closure::RefMutClosure&lt;(&amp;mut std::string::String,), (), ()&gt;
</span><span style="color:#c0c5ce;">Size of a closure c: 16
</span></pre>
<p>在我的机器上函数指针和引用的大小均为 8，因此整个 RefMutClosure struct 的大小为 16。而内置闭包的大小却仅仅为 8，为什么呢？</p>
<p>进一步实验：</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">let mut</span><span style="color:#c0c5ce;"> s = String::from(&quot;</span><span style="color:#a3be8c;">Hello</span><span style="color:#c0c5ce;">&quot;);
</span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> content_of_c: </span><span style="color:#b48ead;">*const </span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">let mut </span><span style="color:#8fa1b3;">c </span><span style="color:#c0c5ce;">= || s.</span><span style="color:#96b5b4;">push</span><span style="color:#c0c5ce;">(&#39;</span><span style="color:#a3be8c;">!</span><span style="color:#c0c5ce;">&#39;);
</span><span style="color:#c0c5ce;">    </span><span style="color:#c0c5ce;">content_of_c = </span><span style="color:#b48ead;">unsafe </span><span style="color:#c0c5ce;">{ std::mem::transmute_copy(&amp;c) };
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">c</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">    </span><span style="color:#96b5b4;">c</span><span style="color:#c0c5ce;">();
</span><span style="color:#c0c5ce;">}
</span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> pointer_to_s: </span><span style="color:#b48ead;">*const </span><span style="color:#c0c5ce;">() = </span><span style="color:#b48ead;">unsafe </span><span style="color:#c0c5ce;">{ std::mem::transmute_copy(&amp;&amp;s) };
</span><span style="color:#c0c5ce;">assert_eq!(content_of_c, pointer_to_s);
</span><span style="color:#c0c5ce;">assert_eq!(s, &quot;</span><span style="color:#a3be8c;">Hello!!</span><span style="color:#c0c5ce;">&quot;);
</span></pre>
<p>可见 Rust 内置闭包实际上<strong>只包含了环境</strong>。原因是 Rust 的闭包是 unboxed 闭包，其函数直接定义为 FnOnce，FnMut 和 Fn，因此，内置闭包对象根本不需要携带函数指针。对内置闭包的函数调用大部分情况下在编译期就绑定了，而不是运行时。即使是 trait object，函数指针也能自动地由虚表提供，非常完美。这样做的好处是方便 LLVM 做内联优化，同时闭包大部分情况下也不需要额外携带一个指针了。</p>
<p>还有一个重要区别是，在上文实现的朴素闭包中，闭包如果拥有引用的 tuple，在 call, call_mut 的调用过程中引用层数增加了（嵌套了），但在内置闭包中并不会这样。这里不做更深入的探讨。</p>
</section>
    </article>


                </div>
            </main>
        </div>
        <footer id="footer">
            
            
    <div class="footer-container container">
        <div id="copyright-container">
            <small id="copyright">© Lin Yinfeng 2018</small>
        </div>
        
        
            <div id="powered-by-container">
                <small id="powered-by">Powered by <a href="https://github.com/gutenberg">Gutenberg</a></small>
            </div>
        
    </div>

            
        </footer>
    

    <script src=https:&#x2F;&#x2F;www.linyinfeng.com&#x2F;layout-helper.js></script>
</body>
</html>
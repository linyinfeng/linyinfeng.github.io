<!DOCTYPE html>
<html lang=cn>
<head>
    
        
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <link rel=stylesheet type="text/css" href=https:&#x2F;&#x2F;www.linyinfeng.com&#x2F;normalize.css>
        <link rel=stylesheet type="text/css" href=https:&#x2F;&#x2F;www.linyinfeng.com&#x2F;style.css>
        <title>
    Lin Yinfeng
    - Futures-rs 博文 Toykio 翻译
</title>
    
</head>
<body>
    
        <header id="header">
            
            
    <div class="header-container container">
        <h1 id="blog-title" class="title"><a href=https:&#x2F;&#x2F;www.linyinfeng.com>Lin Yinfeng</a></h1>
        <nav id="global-nav"><span class="global-nav-item-container"><a class="global-nav-item"
                    href=https:&#x2F;&#x2F;www.linyinfeng.com
                >Home</a></span><span class="global-nav-item-container"><a class="global-nav-item"
                    href=https:&#x2F;&#x2F;www.linyinfeng.com&#x2F;archive
                >Archive</a></span><span class="global-nav-item-container"><a class="global-nav-item"
                    href=https:&#x2F;&#x2F;www.linyinfeng.com&#x2F;links
                >Links</a></span><span class="global-nav-item-container"><a class="global-nav-item"
                    href=https:&#x2F;&#x2F;www.linyinfeng.com&#x2F;status
                >Status</a></span></nav>
    </div>

            
        </header>
        <div id="main-aside-container">
            
    
        
                <aside id="aside">
                    <div id="aside-container">
                        
    
    <div class="toc-container container">
        <h1 class="title toc-title">Table of Contents</h1>
        
    
        <ul class="toc-parent">
                
                <li class="toc-entry">
                    <a href=https:&#x2F;&#x2F;www.linyinfeng.com&#x2F;posts&#x2F;toykio&#x2F;#asynctcpstream>AsyncTcpStream</a>
                    
    

                </li>
                
                <li class="toc-entry">
                    <a href=https:&#x2F;&#x2F;www.linyinfeng.com&#x2F;posts&#x2F;toykio&#x2F;#asyncread-he-asyncwrite>AsyncRead 和 AsyncWrite</a>
                    
    

                </li>
                
                <li class="toc-entry">
                    <a href=https:&#x2F;&#x2F;www.linyinfeng.com&#x2F;posts&#x2F;toykio&#x2F;#shi-jian-xun-huan>事件循环</a>
                    
    

                </li>
                
                <li class="toc-entry">
                    <a href=https:&#x2F;&#x2F;www.linyinfeng.com&#x2F;posts&#x2F;toykio&#x2F;#yi-ge-future-de-yi-sheng>一个 future 的一生</a>
                    
    

                </li>
                
                <li class="toc-entry">
                    <a href=https:&#x2F;&#x2F;www.linyinfeng.com&#x2F;posts&#x2F;toykio&#x2F;#gan-xie>感谢</a>
                    
    

                </li>
                
        </ul>
    

    </div>


                    </div>
                </aside>
            
    

            <main id="main">
                <div id="main-container">
                    
    
                    
    
    <article class="article-container container">
        
    <h1 class="title article-title">
        <a class="article-title-link" href="https:&#x2F;&#x2F;www.linyinfeng.com&#x2F;posts&#x2F;toykio&#x2F;">
            
    <span class="draft-indicator">
        
    </span>
    <span>
        Futures-rs 博文 Toykio 翻译
    </span>

        </a>
    </h1>

        
    <time datetime=2018-08-18T18:24:51+08:00>2018-08-18 18:24</time>

        
    <div class="article-taxonomies"><span class="article-taxonomy"><a class="article-taxonomy-name" href="https:&#x2F;&#x2F;www.linyinfeng.com&#x2F;tags">
                Tags</a><span class="article-terms"><a class="article-term-name" href="https:&#x2F;&#x2F;www.linyinfeng.com&#x2F;tags&#x2F;rust&#x2F;">Rust</a><a class="article-term-name" href="https:&#x2F;&#x2F;www.linyinfeng.com&#x2F;tags&#x2F;future&#x2F;">Future</a></span></span><span class="article-taxonomy"><a class="article-taxonomy-name" href="https:&#x2F;&#x2F;www.linyinfeng.com&#x2F;categories">
                Categories</a><span class="article-terms"><a class="article-term-name" href="https:&#x2F;&#x2F;www.linyinfeng.com&#x2F;categories&#x2F;fan-yi&#x2F;">翻译</a></span></span></div>

        
    
        <section class="article-license">
            
                <div class="license-image">
                    <img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="Creative Commons License" />
                </div>
            
            <small class="license">This work is licensed under a <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a></small>
        </section>
    

        <section class="article-content"><p>本文为 Rust futures-rs 博客 2018 年 8 月 17 日 的 博文 <a href="https://rust-lang-nursery.github.io/futures-rs/blog/2018/08/17/toykio.html">Toykio</a> 的中文翻译。</p>
<p>原文作者 Alexander Polakov（<a href="https://github.com/polachok">@polachok</a>）。</p>
<p>原文目前（2018-08-21）为可选的 MIT 和 Apache 授权，本文使用了其 MIT 授权。<a href="https://github.com/linyinfeng/blog/tree/master/content/posts/toykio/LICENSE-MIT">MIT 许可证副本</a>。</p>
<p id="zola-continue-reading"><a name="continue-reading"></a></p>
<p>在这个博文中我将展示 toykio，一个用于学习带有事件循环的 executor 如何工作的简单 futures executor。Toykio 仅仅提供很少的特性：一个事件循环以及 TCP 流和监听器。但是事实证明，由于 futures 是可组合的，这已经足够用来构建复杂的客户端和服务器程序。</p>
<p>在下文中，我将向你提供 toykio 组件的快速概述。</p>
<h1 id="asynctcpstream"><a class="zola-anchor" href="#asynctcpstream" aria-label="Anchor link for: asynctcpstream">🔗</a><code>AsyncTcpStream</code></h1>
<p>Toykio 定义了 <code>AsyncTcpStream</code> 类型，这是一个标准库中的 <code>TcpStream</code> 的包装。就像标准库中的 <code>TcpStream</code> 一样，<code>connect</code> 函数打开一个连接并将 socket 设为非阻塞模式。这意味着 <code>read()</code> 和 <code>write()</code> 方法将会立刻返回数据或者错误。如果没有足够的数据（对于读操作）或者缓冲区空间（对于写操作），一个特殊的错误 <code>WouldBlock</code> 将被返回。我们将在下一节中讨论如何处理它。</p>
<h1 id="asyncread-he-asyncwrite"><a class="zola-anchor" href="#asyncread-he-asyncwrite" aria-label="Anchor link for: asyncread-he-asyncwrite">🔗</a><code>AsyncRead</code> 和 <code>AsyncWrite</code></h1>
<p><code>AsyncRead</code> 和 <code>AsyncWrite</code> traits 是所有 I/O 特性的基础。<code>AsyncReadExt</code> 和 <code>AsyncWriteExt</code> 的扩展方法（如 <code>read</code> 和 <code>write_all</code>）均在其上构建。这些 traits 提供了一种 futures 与事件循环连接的方法，同时保证它们独立于任何特定的事件循环实现。</p>
<p>让我们看看为 <code>AsyncTcpStream</code> 实现 <code>AsyncRead</code> 的方法：</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">impl </span><span style="color:#c0c5ce;">AsyncRead </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">AsyncTcpStream {
    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">poll_read</span><span style="color:#c0c5ce;">(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">cx</span><span style="color:#c0c5ce;">: &amp;</span><span style="color:#b48ead;">mut</span><span style="color:#c0c5ce;"> Context, </span><span style="color:#bf616a;">buf</span><span style="color:#c0c5ce;">: &amp;</span><span style="color:#b48ead;">mut</span><span style="color:#c0c5ce;"> [</span><span style="color:#b48ead;">u8</span><span style="color:#c0c5ce;">]) -&gt; Poll&lt;Result&lt;</span><span style="color:#b48ead;">usize</span><span style="color:#c0c5ce;">, Error&gt;&gt; {
        </span><span style="color:#b48ead;">match </span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.</span><span style="color:#d08770;">0.</span><span style="color:#96b5b4;">read</span><span style="color:#c0c5ce;">(buf) {
            Ok(len) =&gt; Poll::Ready(Ok(len)),
            Err(</span><span style="color:#b48ead;">ref</span><span style="color:#c0c5ce;"> err) </span><span style="color:#b48ead;">if</span><span style="color:#c0c5ce;"> err.</span><span style="color:#96b5b4;">kind</span><span style="color:#c0c5ce;">() == std::io::ErrorKind::WouldBlock =&gt; {
                </span><span style="color:#65737e;">// 获取 TcpStream 文件描述符
                </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> fd = </span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.</span><span style="color:#d08770;">0.</span><span style="color:#96b5b4;">as_raw_fd</span><span style="color:#c0c5ce;">();
                </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> waker = cx.</span><span style="color:#96b5b4;">waker</span><span style="color:#c0c5ce;">();

                </span><span style="color:#d08770;">REACTOR</span><span style="color:#c0c5ce;">.</span><span style="color:#96b5b4;">with</span><span style="color:#c0c5ce;">(|</span><span style="color:#bf616a;">reactor</span><span style="color:#c0c5ce;">| reactor.</span><span style="color:#96b5b4;">add_read_interest</span><span style="color:#c0c5ce;">(fd, waker.</span><span style="color:#96b5b4;">clone</span><span style="color:#c0c5ce;">()));

                Poll::Pending
            }
            Err(err) =&gt; panic!(&quot;</span><span style="color:#a3be8c;">error {:?}</span><span style="color:#c0c5ce;">&quot;, err),
        }
    }
}
</span></pre>
<p>它尝试从底层的 <code>TcpStream</code> 读取。如果读取成功了，切片将被填上数据。如果失败并且返回了 <code>WouldBlock</code> 错误，就将当前任务的唤醒器注册，这样它将在数据可用的时候被唤醒。下一节中将提到更多有关的细节。</p>
<p><code>AsyncWrite</code> 的实现对 <code>write</code> 做了类似的事。</p>
<h1 id="shi-jian-xun-huan"><a class="zola-anchor" href="#shi-jian-xun-huan" aria-label="Anchor link for: shi-jian-xun-huan">🔗</a>事件循环</h1>
<p><code>Eventloop</code>（通常也被叫做 reactor）是这个 executor 的核心。它像这样被定义：</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">InnerEventLoop {
    </span><span style="color:#bf616a;">read</span><span style="color:#c0c5ce;">: RefCell&lt;BTreeMap&lt;RawFd, Waker&gt;&gt;,
    </span><span style="color:#bf616a;">write</span><span style="color:#c0c5ce;">: RefCell&lt;BTreeMap&lt;RawFd, Waker&gt;&gt;,
    </span><span style="color:#bf616a;">counter</span><span style="color:#c0c5ce;">: Cell&lt;</span><span style="color:#b48ead;">usize</span><span style="color:#c0c5ce;">&gt;,
    </span><span style="color:#bf616a;">wait_queue</span><span style="color:#c0c5ce;">: RefCell&lt;BTreeMap&lt;TaskId, Task&gt;&gt;,
    </span><span style="color:#bf616a;">run_queue</span><span style="color:#c0c5ce;">: RefCell&lt;VecDeque&lt;Wakeup&gt;&gt;,
}
</span></pre>
<ul>
<li><code>read</code> 和 <code>write</code> 是 <code>BTreeMaps</code>，将文件描述符映射到唤醒器。</li>
<li><code>wait_queue</code> 保存了阻塞的等待事件的任务。</li>
<li><code>run_queue</code> 保存了唤醒消息。</li>
</ul>
<p>事件循环提供了在 <code>read</code> 和 <code>write</code> 事件中注册（和移除）兴趣的方法。让我们看看 <code>add_read_interest</code> 做了什么：</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">add_read_interest</span><span style="color:#c0c5ce;">(&amp;</span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">fd</span><span style="color:#c0c5ce;">: RawFd, </span><span style="color:#bf616a;">waker</span><span style="color:#c0c5ce;">: Waker) {
    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">!</span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.read.</span><span style="color:#96b5b4;">borrow</span><span style="color:#c0c5ce;">().</span><span style="color:#96b5b4;">contains_key</span><span style="color:#c0c5ce;">(&amp;fd) {
        </span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.read.</span><span style="color:#96b5b4;">borrow_mut</span><span style="color:#c0c5ce;">().</span><span style="color:#96b5b4;">insert</span><span style="color:#c0c5ce;">(fd, waker);
    }
}
</span></pre>
<p>但它仅仅是把 <code>fd</code> 和 <code>waker</code> 插入到 <code>read</code> 树中！所有的魔法到底发生在哪里？在主循环中。事件循环被叫做循环是有原因的。让我们看看：</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">loop </span><span style="color:#c0c5ce;">{
    </span><span style="color:#65737e;">// 事件循环迭代超时。如果没有描述符就绪我们也继续迭代。
    </span><span style="color:#b48ead;">let mut</span><span style="color:#c0c5ce;"> tv: timeval = timeval {
        tv_sec: </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">,
        tv_usec: </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">,
    };

    </span><span style="color:#65737e;">// 初始化 fd_sets（文件描述符集）
    </span><span style="color:#b48ead;">let mut</span><span style="color:#c0c5ce;"> read_fds: fd_set = </span><span style="color:#b48ead;">unsafe </span><span style="color:#c0c5ce;">{ std::mem::zeroed() };
    </span><span style="color:#b48ead;">let mut</span><span style="color:#c0c5ce;"> write_fds: fd_set = </span><span style="color:#b48ead;">unsafe </span><span style="color:#c0c5ce;">{ std::mem::zeroed() };

    </span><span style="color:#b48ead;">unsafe </span><span style="color:#c0c5ce;">{ </span><span style="color:#d08770;">FD_ZERO</span><span style="color:#c0c5ce;">(&amp;</span><span style="color:#b48ead;">mut</span><span style="color:#c0c5ce;"> read_fds) };
    </span><span style="color:#b48ead;">unsafe </span><span style="color:#c0c5ce;">{ </span><span style="color:#d08770;">FD_ZERO</span><span style="color:#c0c5ce;">(&amp;</span><span style="color:#b48ead;">mut</span><span style="color:#c0c5ce;"> write_fds) };
</span></pre>
<p>唔哦，这里有非常多的 <code>unsafe</code>！但是别担心，这就是 C FFI 的工作方式。我们需要初始化一些 C 结构体，一个超时和 <code>fd_set</code>s。它们后面将被传递给 select(2) 函数。</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// 将所有读兴趣加入到读 fd_sets
    </span><span style="color:#b48ead;">for</span><span style="color:#c0c5ce;"> fd in </span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.read.</span><span style="color:#96b5b4;">borrow</span><span style="color:#c0c5ce;">().</span><span style="color:#96b5b4;">keys</span><span style="color:#c0c5ce;">() {
        </span><span style="color:#b48ead;">unsafe </span><span style="color:#c0c5ce;">{ </span><span style="color:#d08770;">FD_SET</span><span style="color:#c0c5ce;">(*fd, &amp;</span><span style="color:#b48ead;">mut</span><span style="color:#c0c5ce;"> read_fds as </span><span style="color:#b48ead;">*mut</span><span style="color:#c0c5ce;"> fd_set) };
        nfds = std::cmp::max(nfds, fd + </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
    }

    </span><span style="color:#65737e;">// 将所有写兴趣加入到写 fd_sets
    </span><span style="color:#b48ead;">for</span><span style="color:#c0c5ce;"> fd in </span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.write.</span><span style="color:#96b5b4;">borrow</span><span style="color:#c0c5ce;">().</span><span style="color:#96b5b4;">keys</span><span style="color:#c0c5ce;">() {
        </span><span style="color:#b48ead;">unsafe </span><span style="color:#c0c5ce;">{ </span><span style="color:#d08770;">FD_SET</span><span style="color:#c0c5ce;">(*fd, &amp;</span><span style="color:#b48ead;">mut</span><span style="color:#c0c5ce;"> write_fds as </span><span style="color:#b48ead;">*mut</span><span style="color:#c0c5ce;"> fd_set) };
        nfds = std::cmp::max(nfds, fd + </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
    }
</span></pre>
<p>这里我们将之前 <code>read</code> 和 <code>write</code> maps 中的文件描述符置入到 <code>fd_set</code>s 中。</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// `select` 将阻塞到文件描述符上有一些事件发生或者超时
    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> rv = </span><span style="color:#b48ead;">unsafe </span><span style="color:#c0c5ce;">{
        </span><span style="color:#96b5b4;">select</span><span style="color:#c0c5ce;">(
            nfds,
            &amp;</span><span style="color:#b48ead;">mut</span><span style="color:#c0c5ce;"> read_fds,
            &amp;</span><span style="color:#b48ead;">mut</span><span style="color:#c0c5ce;"> write_fds,
            std::ptr::null_mut(),
            &amp;</span><span style="color:#b48ead;">mut</span><span style="color:#c0c5ce;"> tv,
        )
    };

    </span><span style="color:#65737e;">// 不在乎错误
    </span><span style="color:#b48ead;">if</span><span style="color:#c0c5ce;"> rv == -</span><span style="color:#d08770;">1 </span><span style="color:#c0c5ce;">{
        panic!(&quot;</span><span style="color:#a3be8c;">select()</span><span style="color:#c0c5ce;">&quot;);
    } </span><span style="color:#b48ead;">else if</span><span style="color:#c0c5ce;"> rv == </span><span style="color:#d08770;">0 </span><span style="color:#c0c5ce;">{
        debug!(&quot;</span><span style="color:#a3be8c;">timeout</span><span style="color:#c0c5ce;">&quot;);
    } </span><span style="color:#b48ead;">else </span><span style="color:#c0c5ce;">{
        debug!(&quot;</span><span style="color:#a3be8c;">data available on {} fds</span><span style="color:#c0c5ce;">&quot;, rv);
    }
</span></pre>
<p>终于我们使用准备的参数调用了 <code>select</code>。<code>select()</code> 接受 3 个 <code>fd_set</code>s（我们在这个例子中忽略了第三个）和一个超时并且返回一些非 0 值如果一个（或多个）集合中的文件标识符就绪了。我们应该随后找到是哪些文件标识符！</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">    </span><span style="color:#65737e;">// 检查是哪些文件标识符并将合适的 future 置入 run 队列
    </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(fd, waker) in </span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.read.</span><span style="color:#96b5b4;">borrow</span><span style="color:#c0c5ce;">().</span><span style="color:#96b5b4;">iter</span><span style="color:#c0c5ce;">() {
        </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> is_set = </span><span style="color:#b48ead;">unsafe </span><span style="color:#c0c5ce;">{ </span><span style="color:#d08770;">FD_ISSET</span><span style="color:#c0c5ce;">(*fd, &amp;</span><span style="color:#b48ead;">mut</span><span style="color:#c0c5ce;"> read_fds as </span><span style="color:#b48ead;">*mut</span><span style="color:#c0c5ce;"> fd_set) };
        </span><span style="color:#b48ead;">if</span><span style="color:#c0c5ce;"> is_set {
            waker.</span><span style="color:#96b5b4;">wake</span><span style="color:#c0c5ce;">();
        }
    }

    </span><span style="color:#65737e;">// 对 write 做一样的事
    </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(fd, waker) in </span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.write.</span><span style="color:#96b5b4;">borrow</span><span style="color:#c0c5ce;">().</span><span style="color:#96b5b4;">iter</span><span style="color:#c0c5ce;">() {
        </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> is_set = </span><span style="color:#b48ead;">unsafe </span><span style="color:#c0c5ce;">{ </span><span style="color:#d08770;">FD_ISSET</span><span style="color:#c0c5ce;">(*fd, &amp;</span><span style="color:#b48ead;">mut</span><span style="color:#c0c5ce;"> write_fds as </span><span style="color:#b48ead;">*mut</span><span style="color:#c0c5ce;"> fd_set) };
        </span><span style="color:#b48ead;">if</span><span style="color:#c0c5ce;"> is_set {
            waker.</span><span style="color:#96b5b4;">wake</span><span style="color:#c0c5ce;">();
        }
    }
</span></pre>
<p>我们再次遍历了我们的 map 并检查它们是否在 <code>fd_set</code>s 中被设为就绪。当它们被设为就绪，我们就调用它们关联的唤醒器的 wake 方法，这将会把 Wakeup 事件置于准备执行队列上。</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">let mut</span><span style="color:#c0c5ce;"> tasks_done = Vec::new();

    </span><span style="color:#65737e;">// 现在从 run 队列中 pop 任务并 poll 它们
    </span><span style="color:#b48ead;">while let </span><span style="color:#c0c5ce;">Some(wakeup) = </span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.run_queue.</span><span style="color:#96b5b4;">borrow_mut</span><span style="color:#c0c5ce;">().</span><span style="color:#96b5b4;">pop_front</span><span style="color:#c0c5ce;">() {
        </span><span style="color:#b48ead;">let mut</span><span style="color:#c0c5ce;"> handle = </span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.</span><span style="color:#96b5b4;">handle</span><span style="color:#c0c5ce;">();

        </span><span style="color:#b48ead;">if let </span><span style="color:#c0c5ce;">Some(</span><span style="color:#b48ead;">ref mut</span><span style="color:#c0c5ce;"> task) = </span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.wait_queue.</span><span style="color:#96b5b4;">borrow_mut</span><span style="color:#c0c5ce;">().</span><span style="color:#96b5b4;">get_mut</span><span style="color:#c0c5ce;">(&amp;wakeup.index) {
            </span><span style="color:#65737e;">// 如果一个任务返回了 `Poll::Ready`, 我们就完成了它
            </span><span style="color:#b48ead;">if</span><span style="color:#c0c5ce;"> task.</span><span style="color:#96b5b4;">poll</span><span style="color:#c0c5ce;">(wakeup.waker, &amp;</span><span style="color:#b48ead;">mut</span><span style="color:#c0c5ce;"> handle).</span><span style="color:#96b5b4;">is_ready</span><span style="color:#c0c5ce;">() {
                tasks_done.</span><span style="color:#96b5b4;">push</span><span style="color:#c0c5ce;">(wakeup.index);
            }
        }
    }

    </span><span style="color:#65737e;">// 删除已经完成的任务
    </span><span style="color:#b48ead;">for</span><span style="color:#c0c5ce;"> idx in tasks_done {
        </span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.wait_queue.</span><span style="color:#96b5b4;">borrow_mut</span><span style="color:#c0c5ce;">().</span><span style="color:#96b5b4;">remove</span><span style="color:#c0c5ce;">(&amp;idx);
    }

    </span><span style="color:#65737e;">// 如果 `wait_queue` 中没有更多的任务，停止循环
    </span><span style="color:#b48ead;">if </span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.wait_queue.</span><span style="color:#96b5b4;">borrow</span><span style="color:#c0c5ce;">().</span><span style="color:#96b5b4;">is_empty</span><span style="color:#c0c5ce;">() {
        </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;">;
    }
</span></pre>
<p>我们消耗了 <code>run_queue</code>，获取 <code>wait_queue</code> 中的任务索引并询问这些任务。Ready(done) 任务将从 <code>wait_queue</code> 中被移除。</p>
<h1 id="yi-ge-future-de-yi-sheng"><a class="zola-anchor" href="#yi-ge-future-de-yi-sheng" aria-label="Anchor link for: yi-ge-future-de-yi-sheng">🔗</a>一个 future 的一生</h1>
<p>在这节中，我将概括一个 future（让我们以 read 为例子）是如何在 eventloop 中被执行的：</p>
<ul>
<li>首先它由 <code>AsyncTcpStream</code> 的 <code>read()</code> 方法创建，这个方法被所有实现了 <code>AsyncRead</code> trait 的类型实现。</li>
<li>然后使用 <code>run()</code> 或 <code>spawn()</code> 方法在 executor 中 spawn 它。</li>
<li>Executor 调用这个 future 的 poll 方法。Read 中 <code>poll</code> 的实现调用 <code>AsyncTcpStream</code> 的 <code>poll_read()</code> 方法，这个方法将它的兴趣注册到 <code>readable</code> 事件中。</li>
<li>当一个事件发生，future 将被再次 poll。这个循环将被重复直到 future 返回了 ready。</li>
</ul>
<h1 id="gan-xie"><a class="zola-anchor" href="#gan-xie" aria-label="Anchor link for: gan-xie">🔗</a>感谢</h1>
<p>感谢 futures 团队的所有人。特别感谢 <a href="https://github.com/aturon">@aturon</a> 的鼓励和 <a href="https://github.com/MajorBreakfast">@MajorBreakfast</a> 的编辑。</p>
<p>这就是今天的所有内容！你可以在 <a href="https://github.com/polachok/toykio/tree/futures-0.3">github</a> 和 <a href="https://crates.io/crates/toykio">crates.io</a> 上找到 toykio。Hacking 快乐！</p>
</section>
    </article>


                </div>
            </main>
        </div>
        <footer id="footer">
            
            
    <div class="footer-container container">
        <div id="copyright-container">
            <small id="copyright">© Lin Yinfeng 2018-2019</small>
        </div>
        
        
            <div id="powered-by-container">
                <small id="powered-by">Powered by <a href="https://www.getzola.org">Zola</a></small>
            </div>
        
    </div>

            
        </footer>
    

    <script src=https:&#x2F;&#x2F;www.linyinfeng.com&#x2F;layout-helper.js></script>
</body>
</html>